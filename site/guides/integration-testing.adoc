:page-layout: default
:page-title: integration-testing
:page-permalink: /guides/integration-testing

= Understand how to develop integration tests for your cloud native Spring Boot applications

== Introduction

An integral part of the lifecycle of any piece of production grade software is proper application of testing methodologies. +
Of the various types of tests that can be created, integration tests can often be some of the most difficult to create,
not only because of the various real-world systems that need to be up and running (such as the PaaS, a database, other microservices etc), but also because
the tooling isn't as well known as the tooling that exists for unit tests or tests that interact primarily with the framework the application is written in
(think of the Spring Testing Framework here).

Cloud native application are no exception. If anything the large number of interactions such applications may
potentially have with other systems in the PaaS environment makes integration testing all the more necessary.

This guide provides an in depth analysis of how to create and configure your integration tests in order to properly test your
Spring Boot application that is meant to run on Kubernetes or Openshift.
The guide will show how to utilize Maven Failsafe Plugin, Fabric Maven Plugin and Arquillian Cube to
test the following:

* a simple web application that contains no dependencies on other services
* a typical application that needs a database
* a multi-module maven project that needs a cache server to be running

The guide will focus mostly on the configuration that is needed to get all the different components to work together properly
and less on the actual implementation of the test methods (although some simple code will be shown).

== Tools that will be used

=== link:https://maven.apache.org/[Maven]

It goes without saying that having a powerful build tool that can orchestrate the build-test lifecycle is an absolute must.
  By properly utilizing Maven's features we can create a build configuration that is easy to understand and extend while also giving us the all important property of build repeatability. +
Furthermore having the whole manage the build and test lifecycle makes it trivial to introduce proper CI for the project (since any CI system just needs to invoke the appropriate Maven commands)

=== link:https://maven.apache.org/surefire/maven-failsafe-plugin/index.html[Maven Failsafe plugin]

The Maven plugin that is typically used for running integration tests is the Maven Failsafe plugin.
The objective of this plugin is to run tests against the final artifact that is the result of the build phase of a Maven module (which in the case of Spring Boot is the link:https://docs.spring.io/spring-boot/docs/current/reference/html/executable-jar.html[uber-jar]). +
For that reason, the plugin is usually configured to run in the `verify` phase of the link:https://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html#Lifecycle_Reference[Maven lifecycle], which is exactly what we will be doing.

=== link:https://maven.fabric8.io[Fabric8 Maven Plugin]

The Fabric8 Maven Plugin (*FMP* from now on) is a Maven plugin that allows Java applications to be deployed easily to Kubernetes or Openshift.
The plugin effectively allows the developer to deploy their application to Kubernetes or Openshift by issuing a single command, thus freeing the developer of the burden
of having to build a docker image, create resource files etc and triggering a deployment.

FMP provides auto-configuration based on sensible defaults for all things related to build-deploy to Kubernetes / Openshift lifecycle. +
For example it can automatically determine that the application is a Spring Boot application and thus provide proper Kubernetes Health Check endpoints.
Of course it gives the ability to override those defaults when the developer needs more control. +
It thus essentially provides the same type of experience as a developer of Spring Boot applications is used to - a lot of intelligent and sensible defaults, while ceding control when needed.

=== link:http://arquillian.org/arquillian-cube/[Arquillian Cube]

Arquillian Cube is an link:http://arquillian.org/[Arquillian] extension (of which no prior knowledge is necessary for the purposes of this guide) that can be used to manager Docker containers from Java tests. +
Although the Docker capabilities of Arquillian are no doubt impressive, we will only be using the link:http://arquillian.org/arquillian-cube/#_kubernetes[Arquillian Cube Kubernetes] module.
This module provides all necessary constructs needed to write tests against applications that are (or will be) deployed to Kubernetes or Openshift.

As it the case with FMP, Arquillian also provides a host of sensible defaults that can easily be changed to meet the needs of each particular testing scenario.

== Testing a simple web application

Our first task will be to test a simple Spring Boot application that contains it's integration test in the same Maven module as the application source. +
The application we will showcase can be found at link:https://github.com/snowdrop/spring-boot-http-booster[here].

For the purposes of this part of the guide, we just need to know that the application is a Spring Boot application that responds to an `api/greeting` HTTP GET endpoint.

=== Connect to Openshift cluster

The first order of business is to obtain a running Openshift cluster. If you have access to such a cluster, then simply login to it
using:

[source,bash]
----
oc login ...
----

Should you not be lucky enough to have an Openshift cluster available, you'll be delighted to know that it's very easy to run such a cluster on your local machine either using link:https://docs.openshift.org/latest/minishift/getting-started/installing.html[Minishift]
or the command

[source,bash]
----
oc cluster up
----

which is part of the link:https://docs.openshift.com/online/cli_reference/get_started_cli.html[Openshift CLI]

=== Test an already running application

At this point of the guide (having not explained how FMP works) we will deploy the application onto Openshift prior to running the tests. +
This helps us advance our understanding of the entire integration testing process gradually, without having to present all details up front.


==== Deployment of the application on Openshift

Such a task can easily be achieved by utilizing Openshift's Template feature. For the demo application, the Template has already been created and is present link:https://raw.githubusercontent.com/snowdrop/spring-boot-http-booster/master/.openshiftio/application.yaml[here].
by executing the following command:

[source,bash]
----
oc create -f .openshiftio/application.yaml
oc new-app --template=spring-boot-rest-http -p SOURCE_REPOSITORY_URL=https://github.com/snowdrop/spring-boot-http-booster.git -p SOURCE_REPOSITORY_REF=master
----

Without going into all the details of the template, it suffices to mention that the Template contains all necessary Openshift Resources that are necessary to deploy the application, i.e. a `Service`, a `Deployment`, a `Route` etc.

After the application has been deployed, it will have a link:https://docs.openshift.com/container-platform/3.9/architecture/networking/routes.html[Route] named `spring-boot-rest-http`. +
*Route* is the Openshift construct that allows application running inside the cluster to be accessed using a URL from outside the cluster and therefore is the perfect touch point
for our integration tests to interact with the application.

[NOTE]
====
In cases where tests are meant to run inside an Openshift cluster, no `Route` is necessary since the application under test can be reached using it's service name.
However we use `Route` here since it doesn't limit us to running tests inside a cluster, meaning that the tests can run locally or in any CI environment
====

===== Note on Openshift Deployment

Although we won't go into details about how the application actually gets deployed to Openshift when the command above are invoked, we will however provide a high-level overview of the process.

Essentially Openshift uses a process called S2I (Source to Image) that checks out the application code from Github, recognizes the application as a Java Maven application,
uses Maven to build the project's artifact (the Spring Boot uber--jar), creates Docker image inside Openshift's registry
and finally uses it to deploy the application (more details can be found link:https://docs.openshift.org/3.9/using_images/s2i_images/java.html[here])

For this approach to work, Maven needs to be configured to produce a Spring Boot uber-jar (in the same way as is needed to run the application locally).
The relevant Maven configuration is the typical Spring Boot uber-jar configuration like so:

[source,xml]
----
      <plugin>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-maven-plugin</artifactId>
        <configuration/>
        <executions>
          <execution>
            <goals>
              <goal>repackage</goal>
            </goals>
          </execution>
        </executions>
      </plugin>
----

Just as a reminder we note here that this configured results in the production of two jar files when the Maven `package` phase is executed. Openshift is able to correctly use the uber-jar
since the `spring-boot-maven-plugin` takes care to change the suffix of the non uber jar

==== Maven Dependencies Configuration

The first order of business is to add Arquillian to the dependencies of the project. The best way to do that is to import the Arquillian BOM to Maven's
`dependencyManagement` section like so:

[source,xml]
----
  <dependencyManagement>
    <dependencies>
      <dependency>
        <groupId>org.jboss.arquillian</groupId>
        <artifactId>arquillian-bom</artifactId>
        <version>1.4.0.Final</version>
        <type>pom</type>
        <scope>import</scope>
      </dependency>
    </dependencies>
  </dependencyManagement>
----

Adding the appropriate dependencies then becomes a matter of adding the following configuration:

[source,xml]
----
  <dependencies>
    <dependency>
      <groupId>org.jboss.arquillian.junit</groupId>
      <artifactId>arquillian-junit-standalone</artifactId>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>org.arquillian.cube</groupId>
      <artifactId>arquillian-cube-openshift</artifactId>
      <scope>test</scope>
      <exclusions>
        <exclusion>
          <groupId>io.undertow</groupId>
          <artifactId>undertow-core</artifactId>
        </exclusion>
      </exclusions>
    </dependency
   <dependencies>
----

The dependencies above provide add the minimum number of arquillian dependencies needed to interact will the application when it's deployed on Openshift.

==== Maven failsafe plugin configuration

Making sure that the integration tests only run in a proper environment is very important. We don't want developers inadvertently launching the integration tests
by accident only to have them fail because there is no Openshift cluster available and thus creating the false impression that the build is broken.

For that reason we introduce a Maven profile named `openshift-it` which will contain the failsafe plugin configuration needed to run the tests. +
This means that the integration tests will only run when `-Popenshift-it` is present on Maven's command-line invocation.

The profiles section of `pom.xml` will now be:

[source, xml]
----
  <profiles>
    <profile>
      <id>openshift-it</id>  #<1>
      <build>
        <plugins>
          <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-failsafe-plugin</artifactId> #<2>
            <version>2.20</version>
            <configuration>
              <systemPropertyVariables>
                <app.name>${project.artifactId}</app.name> #<3>
              </systemPropertyVariables>
            </configuration>
            <executions>
              <execution>
                <goals>
                  <goal>integration-test</goal>
                  <goal>verify</goal>           #<4>
                </goals>
              </execution>
            </executions>
          </plugin>
        </plugins>
      </build>
    </profile>
  <profiles>
----

<1> The `openshift-it` profile is declared

<2> The failsafe plugin is made part of the project's build when the `openshift-it` profile is enabled

<3> We add a system property named `app.name` that will be available to any piece of code running as part of the failsafe plugin's lifecycle. +
The value of this property is set to the project's artifactId and will be used later in the test code to allow Arquillian to access the application. +
For that reason it is crucial that the value of the `app.name` property matches exactly the name of the `Route` used for the application under test.

<4> We configure two goals for the failsafe plugin, the `integration-test` and `verify` goals. By configuring these goals, the maven surefile plugin will automatically
participate in the corresponding Maven default lifecycle phases. See link:https://maven.apache.org/surefire/maven-failsafe-plugin/plugin-info.html[this] part of the failsafe documentation for more details.

The `integration-test` goal is responsible for actually running the integration tests while `verify` is used in order to make sure that all tests passed (and fail the build if they don't)

[NOTE]
====
It's also worth noting that we haven't specified which tests are considered integration tests. Omitting such link:https://maven.apache.org/surefire/maven-failsafe-plugin/examples/inclusion-exclusion.html[configuration]
means that we are relying on failsafe's default behavior, which is to include all tests that satisfy any of the following patterns:

* `"****/IT*.java"`
* `"**/*IT.java"`
* `"**/*ITCase.java"`
====

==== Arquillian Configuration

Next comes adding the arquillian configuration file which will configure Arquillian to interact with the Openshift environment in the desired way.

.src/test/resources/arquillian.xml
----
<arquillian xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns="http://jboss.org/schema/arquillian"
            xsi:schemaLocation="http://jboss.org/schema/arquillian http://jboss.org/schema/arquillian/arquillian_1_0.xsd">

  <extension qualifier="openshift">
    <property name="namespace.use.current">true</property>
    <property name="env.init.enabled">false</property>
    <property name="enableImageStreamDetection">false</property>
    <property name="namespace.cleanup.enabled">false</property>
  </extension>

</arquillian>
----

The meaning of each bit of the aforementioned  configuration is the following:

* The `openshift` qualifier is needed to tell Arquillian to enable it's Openshift features
* Setting `namespace.use.current` to `true` means that Arquillian will use the current Openshift project (as is returned for example by `oc project -q`) instead of creating a testing one
* Setting `env.init.enabled` to `false` ensures that no Openshift resources will be created by the test (since we expect everything to already be deployed before the test runs)
* Having `enableImageStreamDetection` set to `false` ensures that Arquillian will not perform any search for link:https://docs.openshift.com/container-platform/3.9/dev_guide/managing_images.html[ImageStream] resources on the classpath
* By setting `namespace.cleanup.enabled` to `false` we ensure that Arquillian will not tear down the application when the tests are done

The full extent of the configuration available can be seen link:http://arquillian.org/arquillian-cube/#_kubernetes_configuration_parameters[here] and link:http://arquillian.org/arquillian-cube/#_openshift_configuration_parameters[here]

==== Test code

With the necessary configuration performed and out of our way, we can now turn our attention to writing the actual test code. We will post the test code and then proceed to explain the important parts

[source, java]
----

@RunWith(Arquillian.class) #<1>
public class OpenShiftIT {  #<2>

    @AwaitRoute(path = "/health") #<3>
    @RouteURL("${app.name}")
    private URL baseURL;

    @Test
    public void simplestTest() {   #<4>
        given()
          .baseUri(baseURL + "api/greeting")
          .get()
          .then()
          .statusCode(200);
    }
}
----

<1> We use the `Arquillian` JUnit Runner to give Arquillian control over the lifecycle of the test

<2> The name of the class ends with `IT`, thus indicating to the failsafe plugin that it's an integration test

<3> We are instructing Arquillian to wait (which is the purpose of `AwaitRoute`) until a `Route` named `spring-boot-rest-http` (which is the value we configured for the `app.name` property in `arquillian.xml`)
becomes available. Moreover Arquillian will use the `health` endpoint of said `Route`, waiting until getting an HTTP 200 response. +
It should be noted that this works because the application includes a `/health` endpoint due to the fact that it includes the Spring Boot Actuator. +
When the application becomes available, Arquillian will set the value of `baseURL` to the URL that is used to access the application from outside the cluster.

<4> In this case the test is extremely simple, only testing that the `api/greeting` endpoint responds with HTTP 200

[NOTE]
====
The HTTP interactions are performed and results verified using the excellent link:http://rest-assured.io/[RestAssured] library
====

==== Test execution

The integration test can now be executed from maven like so:

[source,bash]

----
mvn clean verify -Popenshift-it
----

It should be noted that Arquillian's configuration can be overridden on the command line. For example if we needed to tear down the application after the tests execute,
we could use the following command:

[source,bash]

----
mvn clean verify -Popenshift-it -Dnamespace.cleanup.enabled=true
----

==== Note on failsafe classpath and interaction with Spring Boot applications

The test code shown above does not use the source code of the project in any way. +
If that source were to be used in the test code for example to reuse some domain model then test would fail.

The failure would occur as a result of the combination of how the failsafe plugin sets up the classpath for the tests and how
Spring Boot lays out the source classes inside the uber jar. Essentially the failsafe plugin places the uber-jar on the classpath and is unable to locate any of the source
files inside the uber-jar because Spring Boot places them in a custom location (see link:https://github.com/spring-projects/spring-boot/issues/6254#issuecomment-229599865[this] for all the details).

The solution in such cases is to make the failsafe plugin use the non uber-jar which contains the application classes in there standard locations. +
The failsafe configuration that would be used would then be:

[source, xml]
----
  <profiles>
    <profile>
      <id>openshift-it</id>
      <build>
        <plugins>
          <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-failsafe-plugin</artifactId>
            <version>2.20</version>
            <configuration>
              <systemPropertyVariables>
                <app.name>${project.artifactId}</app.name>
              </systemPropertyVariables>
            </configuration>
            <classesDirectory> #<1>
              ${project.build.directory}/${project.build.finalName}.${project.packaging}.original
            </classesDirectory>
            <executions>
              <execution>
                <goals>
                  <goal>integration-test</goal>
                  <goal>verify</goal>
                </goals>
              </execution>
            </executions>
          </plugin>
        </plugins>
      </build>
    </profile>
  <profiles>
----

<1> Force the failsafe plugin to use the non uber-jar as the classes directory. The value of the property matches the name of the non uber jar produced by the `spring-boot-maven-plugin`