:page-layout: default
:page-title: integration-testing
:page-permalink: /guides/integration-testing

= Understand how to develop integration tests for your cloud native Spring Boot applications

== Introduction

An integral part of the lifecycle of any piece of production grade software is proper application of testing methodologies. +
Of the various types of tests that can be created, integration tests can often be some of the most difficult to write,
not only because of the various real-world systems that need to be up and running (such as the PaaS, a database, other microservices etc), but also because the tooling just isn't on par
with the tooling that exists for unit tests or tests that interact primarily with framework the application is written in (like the Spring Testing Framework).

Cloud native application are no exception. If anything the large number of interactions such applications may
potentially have with other systems in the PaaS environment makes integration testing all the more necessary.

This guide provides an in depth analysis of how to create and configure your tests in order to properly test you
Spring Boot application on Kubernetes or Openshift.
We will so how to utilize the Fabric Maven Plugin and Arquillian Cube and the Maven Failsafe plugin to
test the following:

* a simple web application that contains no dependencies on other services,
* a typical appication that needs a database to function and
* a multi-module maven project that needs a cache server to be running in order to properly function

The guide will focus mostly on the configuration that is needed to get all the different components to work together properly and less on the actual implementation of the test methods (although a few tips will be given).

== Tools that will be used

=== link:https://maven.apache.org/[Maven]

It goes without saying that having a powerful build tool that can orchestrate the lifecycle of development time activities is an absolute must.
By properly utilizing Maven's features we can create a build configuration that is easy to understand and extend. +
Furthermore having the whole manage the build and test lifecycle makes it trivial to introduce proper CI for the project (since any CI system just needs to invoke the appropriate Maven commands)

=== link:https://maven.apache.org/surefire/maven-failsafe-plugin/index.html[Maven Failsafe plugin]

The Maven plugin that is typically used for running integration tests is the Maven Failsafe plugin.
The objective of this plugin is to run tests against the final artifact that is the result of the build phase of a Maven module (which in the case of Spring Boot is the link:https://docs.spring.io/spring-boot/docs/current/reference/html/executable-jar.html[uber-jar]). +
For that reason, the plugin is usually configured to run in the `verify` phase of the link:https://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html#Lifecycle_Reference[Maven lifecycle], which is exactly what we will be doing.

=== link:https://maven.fabric8.io[Fabric8 Maven Plugin]

The Fabric8 Maven Plugin (*FMP* from now on) is a Maven plugin that allows Java applications to be deployed easily to Kubernetes or Openshift.
The plugin effectively allows the developer to deploy their application to Kubernetes or Openshift by issuing a single command, thus freeing the developer of the burden
of having to build a docker image, create resource files etc and triggering a deployment

FMP provides auto-configuration out of the box (for example it can automatically determine that the application is a Spring Boot application and thus provide proper Kubernetes Health Check endpoints), but crucially allows
a lot of things to be overridden if needed. +
It thus essentially provides the same type of experience as a developer of Spring Boot applications is used to - a lot of intelligent and sensible defaults, while ceding control if needed

=== link:http://arquillian.org/arquillian-cube/[Arquillian Cube]

Arquillian Cube is an Arquillian extension (of which no prior knowledge is necessary for the purposes of this guide) that can be used to manager Docker containers from Java tests. +
Although the Docker capabilities of Arquillian are no doubt impressive, we will only be using the link:http://arquillian.org/arquillian-cube/#_kubernetes[Arquillian Cube Kubernetes] module.
This module provides all necessary constructs needed to write tests against applications that are (or will be) deployed to Kubernetes or Openshift.

Just like FMP, Arquillian also provides a host of sensible defaults that can easily be changed to meet the needs of each particular testing scenario.

== Testing a simple web application

Our first task will be to test a simple Spring Boot application that contains it's integration test in the same Maven module as the application source. +
The application we will showcase can be found at link:https://github.com/snowdrop/spring-boot-http-booster[here].

For the purposes of this part of the guide, we just need to know that the application responds to an `api/greeting` HTTP GET endpoint.

=== Connect to Openshift cluster

The first order of business is to obtain a running Openshift cluster. If you have access to such a cluster, then simply login to it
using:

[source,bash]
----
oc login ...
----

Should you not be lucky enough to have an Openshift cluster available, you'll be delighted to know that it's very easy to run such a cluster on your local machine either using link:https://docs.openshift.org/latest/minishift/getting-started/installing.html[Minishift]
or the command

[source,bash]
----
oc cluster up
----

which is part of the link:https://docs.openshift.com/online/cli_reference/get_started_cli.html[Openshift CLI]

=== Test an already running application

At this point of the guide (having not explained how FMP works) we will deploy the application onto Openshift outside of Arquillian. +
This helps us slowly progress our understanding of the process.


==== Deploy application on Openshift

Such a task can easily be achieved by utilizing Openshift's Templates, which is specified link:https://raw.githubusercontent.com/snowdrop/spring-boot-http-booster/master/.openshiftio/application.yaml[here] for the demo application.
by executing the following command:

[source,bash]
----
oc create -f .openshiftio/application.yaml
oc new-app --template=spring-boot-rest-http -p SOURCE_REPOSITORY_URL=https://github.com/snowdrop/spring-boot-http-booster.git -p SOURCE_REPOSITORY_REF=master
----


After the application has been deployed, it will `spring-boot-rest-http` as it's link:https://docs.openshift.com/container-platform/3.9/architecture/networking/routes.html[Route]. +
*Route* is the Openshift construct that allows application running inside the cluster to be accessed using a URL from outside the cluster and therefore is the perfect touch point
for our integration tests to interact with.

Later on we show how this `Route` can be automatically generated for the application by FMP

[NOTE]
====
In cases where tests are meant to run inside an Openshift cluster, no Route is necessary since the application under test can be reached using the service name.
However we use `Route` here since it doesn't limit us to running tests inside a cluster, meaning that the tests can run locally or in any CI environment
====


==== Maven Dependencies Configuration

The first order of business is to specify the add Arquillian to the dependencies of the project. The best way to do that is to import the Arquillian BOM to Maven's
`dependencyManagement` section like so:

[source,xml]
----
  <dependencyManagement>
    <dependencies>
      <dependency>
        <groupId>org.jboss.arquillian</groupId>
        <artifactId>arquillian-bom</artifactId>
        <version>1.4.0.Final</version>
        <type>pom</type>
        <scope>import</scope>
      </dependency>
    </dependencies>
  </dependencyManagement>
----

Adding the appropriate dependencies then becomes a matter of adding the following configuration:

[source,xml]
----
  <dependencies>
    <dependency>
      <groupId>org.jboss.arquillian.junit</groupId>
      <artifactId>arquillian-junit-standalone</artifactId>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>org.arquillian.cube</groupId>
      <artifactId>arquillian-cube-openshift</artifactId>
      <scope>test</scope>
      <exclusions>
        <exclusion>
          <groupId>io.undertow</groupId>
          <artifactId>undertow-core</artifactId>
        </exclusion>
      </exclusions>
    </dependency
   <dependencies>
----

The dependencies above provide add the minimum number of arquillian dependencies needed to interact will the application when it's deployed on Openshift.

==== Arquillian Configuration

Next comes adding the arquillian configuration file which will configure Arquillian to interact with the Openshift environment in the proper way.

.src/test/resources/arquillian.xml
----
<arquillian xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns="http://jboss.org/schema/arquillian"
            xsi:schemaLocation="http://jboss.org/schema/arquillian http://jboss.org/schema/arquillian/arquillian_1_0.xsd">

  <extension qualifier="openshift">
    <property name="namespace.use.current">true</property>
    <property name="env.init.enabled">false</property>
    <property name="enableImageStreamDetection">false</property>
    <property name="namespace.cleanup.enabled">false</property>
    <property name="app.name">spring-boot-rest-http</property>
  </extension>

</arquillian>
----

The meaning of each bit of the aforementioned  configuration is the following:

* The `openshift` qualifier is needed to tell Arquillian to enable it's Openshift features
* Setting `namespace.use.current` to `true` means that Arquillian will use the current Openshift project (as is returned for example by `oc project -q`) instead of creating a testing one
* Setting `env.init.enabled` to `false` ensures that no Openshift resources will be created by the test (since we expect everything to already be deployed when the test runs)
* Having `enableImageStreamDetection` set to `false`ensures that Arquillian won't perform any search for ImageStream resources on the classpath
* By setting `namespace.cleanup.enabled` to `false` we ensure that Arquillian will not tear down the application when the tests are done
* `app.name` is a custom property that is set to specify the Openshift Route of the application. Will be used later in the test code

The full extent of the configuration available can be seen link:http://arquillian.org/arquillian-cube/#_kubernetes_configuration_parameters[here] and link:http://arquillian.org/arquillian-cube/#_openshift_configuration_parameters[here]

=== Test code

With the necessary configuration out of our way, we can now turn our attention to writing the actual test code. We will post the test code and then proceed to explain the important parts

[source, java]
----

@RunWith(Arquillian.class) (1)
public class OpenShiftIT {

    @AwaitRoute(path = "/health") (2)
    @RouteURL("${app.name}")
    private URL baseURL;

    @Test
    public void simplestTest() {   (3)
        given()
          .baseUri(baseURL + "api/greeting")
          .get()
          .then()
          .statusCode(200);
    }
}
----

1. We use the `Arquillian` JUnit Runner to give Arquillian control over the lifecycle of the test
2. By using

[source, java]
----
    @AwaitRoute(path = "/health")
    @RouteURL("${app.name}")
    private URL baseURL;
----

we are instructing Arquillian to wait (which is the purpose of `AwaitRoute`) until a `Route` named `spring-boot-rest-http` (which is the value we configured for the `app.name` property in `arquillian.xml`)
becomes available. Moreover Arquillian will inspect the `health` endpoint of said `Route` for a valid HTTP response, waiting until getting one.

[NOTE]
====
The application includes a `/health` endpoint because it includes the Spring Boot Actuator
===

When the application is available, Arquillian will set the value of `baseURL` to the URL where the application is accessible from outside the cluster.


3. The test starts when Arquillian has verified that the Route is accessible and responds correctly. +
In this case the test is extremely simple, only testing that the `api/greeting` endpoint responds with HTTP 200