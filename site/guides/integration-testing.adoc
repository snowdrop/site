:page-layout: default
:page-title: integration-testing
:page-permalink: /guides/integration-testing

= Understand how to develop integration tests for your cloud native Spring Boot applications

An integral part of the lifecycle of any piece of production grade software is proper application of testing methodologies. +
Of the various types of tests that can be created, integration tests can often be some of the most difficult to create,
not only because of the various real-world systems that need to be up and running (such as the PaaS, a database, other microservices etc), but also because
the tooling isn't as well known as the tooling that exists for unit tests or tests that interact primarily with the framework the application is written in
(think of the Spring Testing Framework here).

Cloud native application are no exception. If anything the large number of interactions such applications may
potentially have with other systems in the PaaS environment makes integration testing all the more necessary.

This guide provides an in depth analysis of how to create and configure your integration tests in order to properly test your
Spring Boot application that is meant to run on Kubernetes or Openshift.
The guide will show how to utilize Maven Failsafe Plugin, Fabric Maven Plugin and Arquillian Cube to
test the following:

* a simple web application that contains no dependencies on other services
* a typical application that needs a database
* a multi-module maven project that needs a cache server to be running

The guide will focus mostly on the configuration that is needed to get all the different components to work together properly
and less on the actual implementation of the test methods (although some simple code will be shown).

== What you'll need

* Java 8
* Access to an OpenShift cluster whether locally via https://www.openshift.org/minishift/[minishift] or using the different
  flavors of https://www.openshift.com/products[OpenShift products]

== Knowledge prerequisites

* Intermediate knowledge of Maven
* Working knowledge of Openshift
* Working knowledge of the Fabric Maven Plugin
* Working knowledge of Spring Boot

== Tools that will be used

=== link:https://maven.apache.org/[Maven]

It goes without saying that having a powerful build tool that can orchestrate the build-test lifecycle is an absolute must.
  By properly utilizing Maven's features we can create a build configuration that is easy to understand and extend while also giving us the all important property of build repeatability. +
Furthermore having the whole manage the build and test lifecycle makes it trivial to introduce proper CI for the project (since any CI system just needs to invoke the appropriate Maven commands)

=== link:https://maven.apache.org/surefire/maven-failsafe-plugin/index.html[Maven Failsafe plugin]

The Maven plugin that is typically used for running integration tests is the Maven Failsafe plugin.
The objective of this plugin is to run tests against the final artifact that is the result of the build phase of a Maven module (which in the case of Spring Boot is the link:https://docs.spring.io/spring-boot/docs/current/reference/html/executable-jar.html[uber-jar]). +
For that reason, the plugin is usually configured to run in the `verify` phase of the link:https://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html#Lifecycle_Reference[Maven lifecycle], which is exactly what we will be doing.

=== link:https://maven.fabric8.io[Fabric8 Maven Plugin]

The Fabric8 Maven Plugin (*FMP* from now on) is a Maven plugin that allows Java applications to be deployed easily to Kubernetes or Openshift.
The plugin effectively allows the developer to deploy their application to Kubernetes or Openshift by issuing a single command, thus freeing the developer of the burden
of having to build a docker image, create resource files etc and triggering a deployment.

FMP provides auto-configuration based on sensible defaults for all things related to build-deploy to Kubernetes / Openshift lifecycle. +
For example it can automatically determine that the application is a Spring Boot application and thus provide proper Kubernetes Health Check endpoints.
Of course it gives the ability to override those defaults when the developer needs more control. +
It thus essentially provides the same type of experience as a developer of Spring Boot applications is used to - a lot of intelligent and sensible defaults, while ceding control when needed.

=== link:http://arquillian.org/arquillian-cube/[Arquillian Cube]

Arquillian Cube is an link:http://arquillian.org/[Arquillian] extension (of which no prior knowledge is necessary for the purposes of this guide) that can be used to manager Docker containers from Java tests. +
Although the Docker capabilities of Arquillian are no doubt impressive, we will only be using the link:http://arquillian.org/arquillian-cube/#_kubernetes[Arquillian Cube Kubernetes] module.
This module provides all necessary constructs needed to write tests against applications that are (or will be) deployed to Kubernetes or Openshift.

As it the case with FMP, Arquillian also provides a host of sensible defaults that can easily be changed to meet the needs of each particular testing scenario.

== Testing a simple web application

Our first task will be to test a simple Spring Boot application that contains it's integration test in the same Maven module as the application source. +
The application we will showcase can be found at link:https://github.com/snowdrop/spring-boot-http-booster[here].

For the purposes of this part of the guide, we just need to know that the application is a Spring Boot application that responds to an `api/greeting` HTTP GET endpoint.

=== Connect to Openshift cluster

The first order of business is to obtain a running Openshift cluster. If you have access to such a cluster, then simply login to it
using:

[source,bash]
----
oc login ...
----

Should you not be lucky enough to have an Openshift cluster available, you'll be delighted to know that it's very easy to run such a cluster on your local machine either using link:https://docs.openshift.org/latest/minishift/getting-started/installing.html[Minishift]
or the command

[source,bash]
----
oc cluster up
----

which is part of the link:https://docs.openshift.com/online/cli_reference/get_started_cli.html[Openshift CLI]

=== Test an already running application

At this point of the guide (having not explained how FMP works) we will deploy the application onto Openshift prior to running the tests. +
This helps us advance our understanding of the entire integration testing process gradually, without having to present all details up front.


==== Deployment of the application on Openshift

Such a task can easily be achieved by utilizing Openshift's Template feature. For the demo application, the Template has already been created and is present link:https://raw.githubusercontent.com/snowdrop/spring-boot-http-booster/master/.openshiftio/application.yaml[here].
by executing the following command:

[source,bash]
----
oc create -f .openshiftio/application.yaml
oc new-app --template=spring-boot-rest-http -p SOURCE_REPOSITORY_URL=https://github.com/snowdrop/spring-boot-http-booster.git -p SOURCE_REPOSITORY_REF=master
----

Without going into all the details of the template, it suffices to mention that the Template contains all necessary Openshift Resources that are necessary to deploy the application, i.e. a `Service`, a `Deployment`, a `Route` etc.

After the application has been deployed, it will have a link:https://docs.openshift.com/container-platform/3.9/architecture/networking/routes.html[Route] named `spring-boot-rest-http`. +
*Route* is the Openshift construct that allows application running inside the cluster to be accessed using a URL from outside the cluster and therefore is the perfect touch point
for our integration tests to interact with the application.

[NOTE]
====
In cases where tests are meant to run inside an Openshift cluster, no `Route` is necessary since the application under test can be reached using it's service name.
However we use `Route` here since it doesn't limit us to running tests inside a cluster, meaning that the tests can run locally or in any CI environment
====

===== Note on Openshift Deployment

Although we won't go into details about how the application actually gets deployed to Openshift when the command above are invoked, we will however provide a high-level overview of the process.

Essentially Openshift uses a process called S2I (Source to Image) that checks out the application code from Github, recognizes the application as a Java Maven application,
uses Maven to build the project's artifact (the Spring Boot uber--jar), creates Docker image inside Openshift's registry
and finally uses it to deploy the application (more details can be found link:https://docs.openshift.org/3.9/using_images/s2i_images/java.html[here])

For this approach to work, Maven needs to be configured to produce a Spring Boot uber-jar (in the same way as is needed to run the application locally).
The relevant Maven configuration is the typical Spring Boot uber-jar configuration like so:

[source,xml]
----
      <plugin>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-maven-plugin</artifactId>
        <configuration/>
        <executions>
          <execution>
            <goals>
              <goal>repackage</goal>
            </goals>
          </execution>
        </executions>
      </plugin>
----

Just as a reminder we note here that this configured results in the production of two jar files when the Maven `package` phase is executed. Openshift is able to correctly use the uber-jar
since the `spring-boot-maven-plugin` takes care to change the suffix of the non uber jar

==== Maven Dependencies Configuration

The first order of business is to add Arquillian to the dependencies of the project. The best way to do that is to import the Arquillian BOM to Maven's
`dependencyManagement` section like so:

[source,xml]
----
  <dependencyManagement>
    <dependencies>
      <dependency>
        <groupId>org.jboss.arquillian</groupId>
        <artifactId>arquillian-bom</artifactId>
        <version>1.4.0.Final</version>
        <type>pom</type>
        <scope>import</scope>
      </dependency>
    </dependencies>
  </dependencyManagement>
----

Adding the appropriate dependencies then becomes a matter of adding the following configuration:

[source,xml]
----
  <dependencies>
    <dependency>
      <groupId>org.jboss.arquillian.junit</groupId>
      <artifactId>arquillian-junit-standalone</artifactId>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>org.arquillian.cube</groupId>
      <artifactId>arquillian-cube-openshift</artifactId>
      <scope>test</scope>
      <exclusions>
        <exclusion>
          <groupId>io.undertow</groupId>
          <artifactId>undertow-core</artifactId>
        </exclusion>
      </exclusions>
    </dependency
   <dependencies>
----

The dependencies above provide add the minimum number of arquillian dependencies needed to interact will the application when it's deployed on Openshift.

==== Maven failsafe plugin configuration

Making sure that the integration tests only run in a proper environment is very important. We don't want developers inadvertently launching the integration tests
by accident only to have them fail because there is no Openshift cluster available and thus creating the false impression that the build is broken.

For that reason we introduce a Maven profile named `openshift-it` which will contain the failsafe plugin configuration needed to run the tests. +
This means that the integration tests will only run when `-Popenshift-it` is present on Maven's command-line invocation.

The profiles section of `pom.xml` will now be:

[source, xml]
----
  <profiles>
    <profile>
      <id>openshift-it</id>  #<1>
      <build>
        <plugins>
          <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-failsafe-plugin</artifactId> #<2>
            <version>2.20</version>
            <configuration>
              <systemPropertyVariables>
                <app.name>${project.artifactId}</app.name> #<3>
              </systemPropertyVariables>
            </configuration>
            <executions>
              <execution>
                <goals>
                  <goal>integration-test</goal>
                  <goal>verify</goal>           #<4>
                </goals>
              </execution>
            </executions>
          </plugin>
        </plugins>
      </build>
    </profile>
  <profiles>
----

<1> The `openshift-it` profile is declared

<2> The failsafe plugin is made part of the project's build when the `openshift-it` profile is enabled

<3> We add a system property named `app.name` that will be available to any piece of code running as part of the failsafe plugin's lifecycle. +
The value of this property is set to the project's artifactId and will be used later in the test code to allow Arquillian to access the application. +
For that reason it is crucial that the value of the `app.name` property matches exactly the name of the `Route` used for the application under test.

<4> We configure two goals for the failsafe plugin, the `integration-test` and `verify` goals. By configuring these goals, the maven surefile plugin will automatically
participate in the corresponding Maven default lifecycle phases. See link:https://maven.apache.org/surefire/maven-failsafe-plugin/plugin-info.html[this] part of the failsafe documentation for more details.

The `integration-test` goal is responsible for actually running the integration tests while `verify` is used in order to make sure that all tests passed (and fail the build if they don't)

[NOTE]
====
It's also worth noting that we haven't specified which tests are considered integration tests. Omitting such link:https://maven.apache.org/surefire/maven-failsafe-plugin/examples/inclusion-exclusion.html[configuration]
means that we are relying on failsafe's default behavior, which is to include all tests that satisfy any of the following patterns:

* `"****/IT*.java"`
* `"**/*IT.java"`
* `"**/*ITCase.java"`
====

==== Arquillian Configuration

Next comes adding the arquillian configuration file which will configure Arquillian to interact with the Openshift environment in the desired way.

.src/test/resources/arquillian.xml
----
<arquillian xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns="http://jboss.org/schema/arquillian"
            xsi:schemaLocation="http://jboss.org/schema/arquillian http://jboss.org/schema/arquillian/arquillian_1_0.xsd">

  <extension qualifier="openshift">
    <property name="namespace.use.current">true</property>
    <property name="env.init.enabled">false</property>
    <property name="enableImageStreamDetection">false</property>
    <property name="namespace.cleanup.enabled">false</property>
  </extension>

</arquillian>
----

The meaning of each bit of the aforementioned  configuration is the following:

* The `openshift` qualifier is needed to tell Arquillian to enable it's Openshift features
* Setting `namespace.use.current` to `true` means that Arquillian will use the current Openshift project (as is returned for example by `oc project -q`) instead of creating a testing one
* Setting `env.init.enabled` to `false` ensures that no Openshift resources will be created by the test (since we expect everything to already be deployed before the test runs)
* Having `enableImageStreamDetection` set to `false` ensures that Arquillian will not perform any search for link:https://docs.openshift.com/container-platform/3.9/dev_guide/managing_images.html[ImageStream] resources on the classpath
* By setting `namespace.cleanup.enabled` to `false` we ensure that Arquillian will not tear down the application when the tests are done

The full extent of the configuration available can be seen link:http://arquillian.org/arquillian-cube/#_kubernetes_configuration_parameters[here] and link:http://arquillian.org/arquillian-cube/#_openshift_configuration_parameters[here]

==== Test code

With the necessary configuration performed and out of our way, we can now turn our attention to writing the actual test code. We will post the test code and then proceed to explain the important parts

[source, java]
----

@RunWith(Arquillian.class) #<1>
public class OpenShiftIT {  #<2>

    @AwaitRoute(path = "/health") #<3>
    @RouteURL("${app.name}")
    private URL baseURL;

    @Test
    public void simplestTest() {   #<4>
        given()
          .baseUri(baseURL + "api/greeting")
          .get()
          .then()
          .statusCode(200);
    }
}
----

<1> We use the `Arquillian` JUnit Runner to give Arquillian control over the lifecycle of the test

<2> The name of the class ends with `IT`, thus indicating to the failsafe plugin that it's an integration test

<3> We are instructing Arquillian to wait (which is the purpose of `AwaitRoute`) until a `Route` named `spring-boot-rest-http` (which is the value we configured for the `app.name` property in `arquillian.xml`)
becomes available. Moreover Arquillian will use the `health` endpoint of said `Route`, waiting until getting an HTTP 200 response. +
It should be noted that this works because the application includes a `/health` endpoint due to the fact that it includes the Spring Boot Actuator. +
When the application becomes available, Arquillian will set the value of `baseURL` to the URL that is used to access the application from outside the cluster.

<4> In this case the test is extremely simple, only testing that the `api/greeting` endpoint responds with HTTP 200

[NOTE]
====
The HTTP interactions are performed and results verified using the excellent link:http://rest-assured.io/[RestAssured] library
====

==== Test execution

The integration test can now be executed from maven like so:

[source,bash]

----
mvn clean verify -Popenshift-it
----

It should be noted that Arquillian's configuration can be overridden on the command line. For example if we needed to tear down the application after the tests execute,
we could use the following command:

[source,bash]

----
mvn clean verify -Popenshift-it -Dnamespace.cleanup.enabled=true
----

==== Note on failsafe classpath and interaction with Spring Boot applications

The test code shown above does not use the source code of the project in any way. +
If that source were to be used in the test code for example to reuse some domain model then test would fail.

The failure would occur as a result of the combination of how the failsafe plugin sets up the classpath for the tests and how
Spring Boot lays out the source classes inside the uber jar. Essentially the failsafe plugin places the uber-jar on the classpath and is unable to locate any of the source
files inside the uber-jar because Spring Boot places them in a custom location (see link:https://github.com/spring-projects/spring-boot/issues/6254#issuecomment-229599865[this] for all the details).

The solution in such cases is to make the failsafe plugin use the non uber-jar which contains the application classes in there standard locations. +
The failsafe configuration that would be used would then be:

[source, xml]
----
  <profiles>
    <profile>
      <id>openshift-it</id>
      <build>
        <plugins>
          <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-failsafe-plugin</artifactId>
            <version>2.20</version>
            <configuration>
              <systemPropertyVariables>
                <app.name>${project.artifactId}</app.name>
              </systemPropertyVariables>
            </configuration>
            <classesDirectory> #<1>
              ${project.build.directory}/${project.build.finalName}.${project.packaging}.original
            </classesDirectory>
            <executions>
              <execution>
                <goals>
                  <goal>integration-test</goal>
                  <goal>verify</goal>
                </goals>
              </execution>
            </executions>
          </plugin>
        </plugins>
      </build>
    </profile>
  <profiles>
----

<1> Force the failsafe plugin to use the non uber-jar as the classes directory. The value of the property matches the name of the non uber jar produced by the `spring-boot-maven-plugin`

=== Deploy application as part of the integration test process

Up until now we have been operating under the assumption that the tests would be executed against an application that was running before Maven was invoked. +
Although such a scenario is useful in some cases, it would also be great for CI purposes if the application could be deployed to Openshift from source
as part of the Maven build.

In this section we will describe in depth how we can configure Maven in order to provide the developer with a single command that utilizes features provided by FMP and Arquillian
to launch and test the application.

The end result is that executing a command like

[source,bash]
----
mvn clean verify -Popenshift,openshift-it
----

will handle the entire build-deploy-test lifecycle.

==== Overview

The next steps give a bird's eye view of the parts that come in to play:

* FMP generates Openshift resources
* Maven compiles the source classes
* The spring-boot-maven-plugin creates an uber-jar containing the output of the previous two processes
* FMP applies an `ImageStream` on Openshift using the uber-jar as the input to the binary S2I build
* Failsafe uses the uber-jar as part of the classpath it provides the tests with
* Arquillian searches for Openshift resources on the test classpath.
* The Openshift resources produced by FMP are found and the application is deployed
* Arquillian initiates the tests once the application has been successfully deployed

==== FMP configuration

First of all we need to make sure that FMP goals are not executed by accident as part of the default lifecycle since they affect the Openshift cluster's state.
For that reason all of the FMP configuration will reside inside the `openshift` profile, meaning that the profile will need
to be enabled explicitly for any of the FMP goals to be executed.

[NOTE]
====
The reason we introduce a new profile and avoid reusing the `openshift-it` profile is that we might want
to execute FMP's goals independently of the integration testing process
====

For the purposes of this guide, we don't need to perform any specific configuration of FMP, we can just accept the defaults
and configure it (inside the `profiles` section) like so:

[source,xml]
----
    <profile>
      <id>openshift</id>
      <build>
        <plugins>
          <plugin>
            <groupId>io.fabric8</groupId>
            <artifactId>fabric8-maven-plugin</artifactId>
            <executions>
              <execution>
                <id>fmp</id>
                <goals>
                  <goal>resource</goal>
                  <goal>build</goal>
                </goals>
              </execution>
            </executions>
          </plugin>
        </plugins>
      </build>
    </profile>
----

The two FMP goals that we specify are `resource` and `build`.

link:https://maven.fabric8.io/#fabric8:resource[resource] is automatically attached to the `process-resources` phase of the default Maven lifecycle
and it's purpose is to create the Openshift resources (as files on the file system) that are needed to deploy the application. +
These resources include the `Service`, `DeploymentConfig` and `Route` which are all necessary to make the application available outside the cluster. +

It's worth noting that the produced Openshift resources are placed inside `target/classes/META-INF/fabric8` and the specific file that will be used later
by Arquillian is `target/classes/META-INF/fabric8/openshift.yml`. +
Having the files under `target/classes` means that when Maven packages the application and creates the final artifact (the Spring Boot uber-jar),
the all too important `META-INF/fabric8/openshift.yml` file will be present inside it.

link:https://maven.fabric8.io/#fabric8:build[build] is automatically attached to the `pre-integration-test` phase of the default Maven lifecycle
and takes care of applying the `BuildConfiguration` and `ImageStream` resources to the cluster that are necessary to deploy the application later on.

[NOTE]
====
A great way to see the plugins that are attached to each lifecycle is by executing the following command
[source,bash]
----
mvn fr.jcgay.maven.plugins:buildplan-maven-plugin:list-phase -Popenshift,openshift-it
----
====


==== How FMP resources are used before the tests are run

Now that we have a firm grasp on how and when FMP creates the necessary Openshift resources, we will close the loop and describe how these resources are used
in order to launch the application before Arquillian starts the actual tests.

As should be evident from the previous section, by the time Arquillian launches (as part of the `integration-test` phase of the default Maven lifecycle),
FMP has taken care of two things:

* An `ImageStream` has been applied on Openshift that contains the Docker image built from the application's uber-jar
* A YAML file containing all the Openshift resources necessary to launch the application has been created at `target/classes/META-INF/fabric8/openshift.yml`

The aforementioned `openshift.yml` file has also been copied to the Spring Boot uber-jar (with the `META-INF` directory structure preserved).
This is important since as was described earlier in the guide, the uber-jar is part of the test classpath created by the failsafe plugin.

When Arquillian is launched, if it has been configured to have `env.init.enabled` set to `true`, it dutifully looks for `META-INF/fabric8/openshift.yml`
inside it's classpath. Once the file is found, it used to deploy the application to Openshift.

The rest of what Arquillian does is the same as described in the section about testing an already running application.

Just for reference, the Arquillian configuration we use in this case is:

.src/test/resources/arquillian.xml
----
<arquillian xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns="http://jboss.org/schema/arquillian"
            xsi:schemaLocation="http://jboss.org/schema/arquillian http://jboss.org/schema/arquillian/arquillian_1_0.xsd">

  <extension qualifier="openshift">
    <property name="namespace.use.current">true</property>
    <property name="env.init.enabled">true</property>
    <property name="enableImageStreamDetection">false</property>
  </extension>

</arquillian>
----


== Testing an application that uses a database

In this section we will introduce some extra complexity into the integration testing scenario by using a
link:https://github.com/snowdrop/spring-boot-crud-booster[demo application] that requires a database to be present.

We will show how easy it is for Arquillian to take care of the deployment of a database as well as part of the test setup.

=== Configuring Arquillian to additionally setup the database

As has been noted before, Arquillian offers a ton of flexibility in order to be able to address a host of different
integration testing scenarios. +
In this section we will see just how a very simple configuration change to the configuration we have been using so far,
suffices to get a database running on the Openshift cluster.

First of all we need to add an Openshift file that describes the database we want to deploy:

.src/test/resources/database.yml
----
apiVersion: v1
items:
- apiVersion: v1
  kind: ImageStream
  metadata:
    annotations:
      openshift.io/generated-by: OpenShiftNewApp
    creationTimestamp: null
    labels:
      app: my-database
    name: my-database
  spec:
    lookupPolicy:
      local: false
    tags:
    - annotations:
        openshift.io/imported-from: openshift/postgresql-92-centos7
      from:
        kind: DockerImage
        name: openshift/postgresql-92-centos7
      generation: null
      importPolicy: {}
      name: latest
      referencePolicy:
        type: ""
  status:
    dockerImageRepository: ""
- apiVersion: v1
  kind: DeploymentConfig
  metadata:
    annotations:
      openshift.io/generated-by: OpenShiftNewApp
    creationTimestamp: null
    labels:
      app: my-database
    name: my-database
  spec:
    replicas: 1
    selector:
      app: my-database
      deploymentconfig: my-database
    strategy:
      resources: {}
    template:
      metadata:
        annotations:
          openshift.io/generated-by: OpenShiftNewApp
        creationTimestamp: null
        labels:
          app: my-database
          deploymentconfig: my-database
      spec:
        containers:
        - env:
          - name: POSTGRESQL_DATABASE
            value: my_data
          - name: POSTGRESQL_PASSWORD
            value: secret
          - name: POSTGRESQL_USER
            value: luke
          image: openshift/postgresql-92-centos7
          name: my-database
          ports:
          - containerPort: 5432
            protocol: TCP
          resources: {}
          volumeMounts:
          - mountPath: /var/lib/pgsql/data
            name: my-database-volume-1
        volumes:
        - emptyDir: {}
          name: my-database-volume-1
    test: false
    triggers:
    - type: ConfigChange
    - imageChangeParams:
        automatic: true
        containerNames:
        - my-database
        from:
          kind: ImageStreamTag
          name: my-database:latest
      type: ImageChange
  status:
    availableReplicas: 0
    latestVersion: 0
    observedGeneration: 0
    replicas: 0
    unavailableReplicas: 0
    updatedReplicas: 0
- apiVersion: v1
  kind: Service
  metadata:
    annotations:
      openshift.io/generated-by: OpenShiftNewApp
    creationTimestamp: null
    labels:
      app: my-database
    name: my-database
  spec:
    ports:
    - name: 5432-tcp
      port: 5432
      protocol: TCP
      targetPort: 5432
    selector:
      app: my-database
      deploymentconfig: my-database
  status:
    loadBalancer: {}
kind: List
metadata: {}
----

To make arquillian deploy the database as part of the environment creation process, all we need to do is configure the `env.dependencies` property.
The final `arquillian.xml` configuration file looks like:

.src/test/resources/arquillian.xml
----
<arquillian xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns="http://jboss.org/schema/arquillian"
            xsi:schemaLocation="http://jboss.org/schema/arquillian http://jboss.org/schema/arquillian/arquillian_1_0.xsd">

  <extension qualifier="openshift">
    <property name="namespace.use.current">true</property>
    <property name="env.init.enabled">true</property>
    <property name="enableImageStreamDetection">false</property>
    <property name="namespace.cleanup.enabled">false</property>
    <property name="env.dependencies">file://${basedir}/target/test-classes/database.yml</property> #<1>
  </extension>

</arquillian>
----

<1> The `env.dependencies` is a comma-separated list of URLs to more environment dependencies.

The only tricky thing about the value of `env.dependencies` is that it uses a Maven variable which means that we need to make sure that
test resources have been configured to have the Maven variables substituted. +
That can easily be achieved by adding the following inside the `build` section:

[source,xml]
----
    <testResources>
      <testResource>
        <directory>src/test/resources</directory>
        <filtering>true</filtering>
      </testResource>
    </testResources>
----

See link:https://maven.apache.org/plugins/maven-resources-plugin/examples/filter.html[this] part of the Maven documentation for more details.

== Testing a multi-module maven project that uses a Cache server

TODO